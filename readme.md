# Шпаргалка по курсу GIT от Яндекс  


## 1.Основы работы с Терминалом:  

**pwd** - узнать пусть к текущей дир-и;  
**cd ~** - перейти в домашнюю дир-ю;  
**cd ..** - вернуться в родительскую дир-ю;  
**cd _название /след папка_** - переместиться сразу к след. папке;  
**ls** - вывести содержимое дир-и;  
**ls -a** - показать скрытые файлы;  
**ls ~** - показать содержимое родительской дир-и;  
**touch/mkdir** - создать файл или дир-ю;  
**mkdir -p _dir1/dir-inside/die-deeper_** - создать структуру дир-й;  
**cp _что копируем куда_** - копирование;  
**cp _что копируем что копируем что копируем куда_** - копирование нескольких файлов;  
**mv** - перемещение;  
**cat** - прочитать файл в консоль;  
**rm, rmdir, rm -r** - удалить файл, папку, папку с файлами;  
**mk dir second-project && cd second-project && touch index.html style.css** - выполнить сразу несколько команд;  
**echo "Вторая строка файла" >> file.txt** - допишет новую строку в конец файла;  
**echo "Новая строка" > file.txt** - сотрёт содержимое файла, то есть перезапишет файл целиком.  
Выйти из редактора Vim: нажать Esc, ввести :qa!, нажать Enter;  
**chmod +x имя файла.sh** - эта команда сделает файл исполняемым;  
**./имя файла.sh** - эта команда исполнит скрипт;  


## 2.Основы Git:  

**git config --global user.name "_____"**   
**git config --global user.email _____** - заносим информацию о пользователе в Git, имя и почта;  

Все настройки хранятся в .gitconfig в домашней дир-ии.  

**cat ~/.gitconfig** или **git config --list** - вывести содержимое файла конфигурации;  
**git init** - сделать папку реп-ем;  
**rm -rf .git** - _разгитить_ папку;  
**git status** - состояние реп-я;  
**git add --all** - добавить все файлы;  
**git add .** - добавить всю папку целиком;  
**git commit -m "____"** - сохранить, зафиксировать изменения;  
**git log** - история коммитов.    

## 3.Работа с SSH ключем:  

**cd ~** - перейти в домашнюю дир-ю;  
**ls -la .ssh/** - вывести список ключей (если они есть);  
**ssh-keygen -t ed25519 -C "эл. почта"** или **ssh-keygen -t rsa -b 4096 -C "эл. почта"** - генерация SSH пары;  
**ls -a ~/.ssh** или **ls -la ~/.ssh** - посмотреть пару ssh ключей;  

**clip < ~/.ssh/id_ed25519.pub** или **clip < ~/.ssh/id_rsa.pub** - копируем содержимое в буфер;  
**cat ~/.ssh/id_ed25519.pub** или **cat ~/.ssh/id_rsa.pub** - показать в терминале, что б скопировать в ручную;  
**ssh -T git@gitgub.com** - проверить ключ;  


**git remote add origin _ssh ссылка с github_** - привязка удаленного реп-я к локальному;  
_origin_ - имя(псевдоним) удаленного репозитория  
**git remote -v** - проверить, что реп-ии связаны;  
**git push -u origin main(master)** - отправка изменений в удаленный реп-й. Первый раз нужно делать с флагом -u. Он связывает одноименный локальный и удаленный реп-ий.  

## 4.Хеш — идентификатор коммита  

Git хранит таблицу соответствий хеш → информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.  
После вызова **git log** появляется список коммитов.  
**git log --oneline** автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь.  

## 5.HEAD — всему голова  

При вызове команды git log вы также могли заметить надпись (HEAD -> master).  
Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git  

## 6.Статусы файлов в Git  

Статусы **untracked/tracked**, **staged** и **modified**.  

    Статусом untracked помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность tracked, в который попадают все файлы, отслеживаемые Git.  
    Файл переходит в статус staged после выполнения **git add**.  
    Статус modified означает, что файл был изменён.  
    Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.  

    Команда **git status** всегда подскажет, что происходит с файлом: например, он добавлен в список «на коммит» или ещё вообще не отслеживается, или изменён.  
    **git status** показывает явно следующие состояния файлов: untracked, staged и modified.  
    **git status** подсказывает, какие команды можно выполнить, чтобы поменять состояние файла.  

## 7.Оформление сообщений к коммитам  

### Корпоративный  
В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.  

$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами"  

### Conventional Commits  
Conventional Commits предлагает такой формат коммита: <type>: <сообщение>. Первая часть type — это тип изменений. Таких типов достаточно много. Вот два примера:  

    feat (сокращение от англ. feature) — для новой функциональности;  
    fix (от англ. «исправить», «устранить») — для исправленных ошибок.  

git commit -m "feat: добавить подсчёт суммы заказов за неделю"  

### GitHub-стиль  
GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё.  

$ git commit -m "Исправить #334, добавить график температуры"  

## 8.Как исправить коммит  

**git commit --amend --no-edit** - дополнить коммит новыми файлами;  
С опцией --amend команда commit не создаст новый коммит, а дополнит последний.  

**git commit --amend -m "Новое сообщение"** - изменить сообщение коммита.  

**--amend** рассчитан на работу с последним коммитом (HEAD).  

## 9.Как откатиться назад, если «всё сломалось»  

**git restore --staged <file>** - выполнить **unstage** изменений, переведёт файл из staged обратно в modified или untracked;  
**git reset --hard <commit hash>** - «откатит» историю до коммита с хешем <hash>. Более поздние коммиты потеряются!;  
**git restore <file>** - откатить изменения, которые не попали ни в **staging**, ни в коммит. «Откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии.;  
Может быть так, что вы случайно изменили файл, который не планировали. Теперь он отображается в Changes not staged for commit (modified). Чтобы вернуть всё «как было», можно выполнить команду git restore <file>.  
Изменения в файле «откатятся» до последней версии, которая была сохранена через git commit или git add.  

## 10.Просматриваем изменения в файлах  

### Просматриваем изменения в файлах  

 
**git diff** - сравнит последнюю закоммиченную версию файла с той, что находится в состоянии **modified**;  
**git diff --staged** - покажет изменения в **staged-файлах** относительно последних закоммиченных версий.  

### Сопоставляем коммиты  

**git diff <предыдущий коммит> <следующий коммит>** - сравнивать изменения в двух коммитах; 
По сути команда **git diff A B** выводит список инструкций: как превратить состояние A в состояние B. Если поменять A и B местами (**git diff B A**), то и инструкции будут обратные: как превратить B в A. При этом все зелёные строки станут красными, и наоборот.
Попробуйте **git diff <конец> <начало>**. Вместо <конец> можно также передать **HEAD**.  

## 11.Игнорирование файлов в Git  

Чтобы Git игнорировал такие файлы и не пытался добавить их в репозиторий, нужно создать файл **.gitignore**  
Правила из **.gitignore** применяются только к новым (untracked) файлам. Если файл уже попал в staging area или в коммит, то правила на него не распространяются.  
Сам файл .gitignore — это обычный файл в репозитории. Его тоже стоит закоммитить.  

### Комментарий  
\# вот так можно писать комментарии;
\# они ничего не значат для .gitignore,
\# но они могут быть полезны, чтобы понять, зачем было добавлено то или иное правило  

### Просто название файла  
Допустим, нужно, чтобы Git игнорировал все файлы .DS_Store. Для этого достаточно добавить в .gitignore строку с названием файла.  

 для macOS  
.DS_Store  

### Звёздочка (*)  

 Игнорировать все файлы, которые заканчиваются на .jpeg  
*.jpeg  

 Игнорировать все файлы "tmp" во всех подпапках папки docs  
docs/*/tmp  

 Если задать правило, которое состоит только из звёздочки, Git будет игнорировать все файлы. Это происходит потому, что под звёздочку подходит любое имя файла.

 Странное, но возможное правило "игнорировать все файлы"  
* 

### Вопросительный знак (?)  
Вопросительный знак ? соответствует одному любому символу.  

file?.txt  

Если сохранить такую запись в .gitignore, то будут проигнорированы, например, файлы fileA.txt и file1.txt. А вот файл file12.txt не будет проигнорирован, потому что в его названии два символа после file, а не один.  

### Квадратные скобки ([…])   
Игнорировать файлы file0.txt, file1.txt и file2.txt  
При этом не игнорировать file3.txt, file4.txt, ...  
file[0-2].txt  

В скобках можно либо перечислить символы ([abc]), либо задать диапазон ([a-z]).  

### Слеш (/)  
Косая черта, или слеш (/), указывает на каталоги. Если шаблон в .gitignore начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории.  

Игнорировать todo.txt в корне репозитория  
/todo.txt  

Для сравнения: spam.txt будет игнорироваться во всех папках  
spam.txt  

Если шаблон заканчивается слешем, то правило применится только к папке.  

Игнорировать папку build  
build/  

### Парные звёздочки (**)  
Функция парных звёздочек (**) похожа на функцию одинарной (*). Отличие в том, как они работают с вложенными папками. Двойная звёздочка может соответствовать любому количеству таких папок (в том числе нулю). Одинарная может соответствовать только одной.  
Игнорировать файлы "docs/current/tmp", "docs/old/tmp",  
 а также "docs/old/saved/a/b/c/d/tmp"  
 и даже "docs/tmp", потому что ноль вложенных папок тоже подходит  
docs/**/tmp  

 Игнорировать только "docs/current/tmp" и "docs/old/tmp"  
 файл "docs/old/saved/a/b/c/d/tmp" не попадает в правило  
docs/*/tmp  

### Восклицательный знак (!)  
Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).  
 Игнорировать все JPEG-файлы  
*.jpeg  

 Но только не мем с Doge  
!doge.jpeg  

### .gitignore и git status  
Игнорируемые файлы не отображаются в выводе команды git status, иначе они бы засоряли вывод.  
Если всё же нужно отобразить все игнорируемые файлы, то это можно сделать с помощью ключа --ignored: git status --ignored. В таком случае в выводе git status появится раздел Ignored files.  


## 12.Клонируем репозиторий  

**git clone ссылка** - клонировать репозиторий;  
Команда **git clone** автоматически связывает локальный и удалённый репозиторий. То есть если в GitHub-репозитории что-то поменяется (например, добавятся коммиты), вам не нужно будет заново клонировать его. Достаточно будет выполнить команду, которая обновит вашу копию.  
Убедитесь в том, что репозитории связаны, командой **git remote -v**.  

## 13.Выполняем Fork  

Fork (англ. «развилка», «ответвление»), или «форк», — это GitHub-операция;  
Напрямую с Git она не связана. «Форк» создаёт копию репозитория в аккаунте GitHub. Такая копия будет полностью независима. Изменения, которые вы внесёте, не будут синхронизированы с исходным репозиторием.  
В процессе «форка» создаётся копия всех файлов, истории коммитов и веток. Эта копия сохраняется в вашей учётной записи GitHub.  
Вот некоторые из распространённых причин использования «форков»:  

    Вы хотите внести свой вклад в проект (например, open source), но не имеете прав на изменение исходного репозитория. Тогда вы можете сделать «форк», добавить нужные правки, а затем отправить запрос на включение этих изменений в оригинальный проект.  
    Вы хотите развивать проект независимо от исходного. Допустим, создатели проекта решили, что не будут добавлять функциональность, которая вам необходима. В таком случае вы можете сделать «форк» и добавить её самостоятельно.  

«Форк» или clone?
 Обычно комбинация «форк» + clone используется для внесения изменений в публичные репозитории. В этом случае «форк» становится подготовительным этапом перед клонированием чужого репозитория на ваш компьютер.  
 Если репозиторий приватный или это репозиторий вашей компании, при работе с ним достаточно clone.  
Копия, которая получена с помощью «форка», полностью независима от оригинального проекта — изменения не будут синхронизированы.  

## 14. Что такое ветка  

Ветка (англ. branch) — это изолированный поток разработки проекта. В таком потоке можно проверять разные идеи, тестировать новую функциональность и так далее.  
Благодаря веткам несколько человек могут работать над одним репозиторием и не мешать друг другу. А ещё ветки помогают декомпозировать большую и страшную задачу на маленькие и понятные.  
**git branch** - посмотреть ветки проекта;  

## 15. Создаём ветку  

**git branch <название_ветки>** - создать ветку  
В названии ветки есть слеш — что это значит?
Название ветки в Git может состоять из букв, цифр, а также включать любой из четырёх символов: ., -, _, /.  
Эти символы не несут особого смысла. Например, ветка feature/add-branch-info могла бы называться feature_add-branch-info или feature-add-branch.  
Обратите внимание, что ветки не образуют иерархии, как директории, разделённые символом /.  
**git branch -a** - покажи все известные ветки, как локальные так и удаленные.  

### Как назвать новую ветку  
Мы будем использовать указатели feature (англ. «особенность», «деталь») для веток, где прорабатывается новая функциональность, и bugfix (от англ. bug — «жук», «ошибка» и fix — «исправить») для веток, где ведётся работа по исправлению ошибок.  
После ключевого слова идёт слеш и описание проблемы или задачи (например, /add-branch-info). Это описание не должно содержать пробелов — следует использовать нижнее подчёркивание или дефис. В наших примерах мы будем использовать дефис.  

**git checkout <название_ветки>** - переключиться на другую ветку  
**git checkout -b <название_ветки>** - создать ветку и сразу переключиться в нее  

Ветка в Git — это указатель на коммит. Когда вы делаете новый коммит в ветке, этот указатель передвигается вперёд.  
Ветка указывает на коммит, который сделан в ней последним. При этом две ветки могут ссылаться на один и тот же коммит — например, если вы только что создали ветку, но ещё не успели внести в неё коммит.  

## 16. Сравниваем ветки  

**git diff <название_ветки1> <название_ветки2>** - сравнить ветки;  

git diff может сравнивать ветки по их названиям. Например, команда git diff main feature/my-feature выведет разницу между основной веткой и веткой feature/my-feature.  
Git поддерживает суффикс навигации ~. С его помощью можно сослаться на предыдущие коммиты. Например, если вы находитесь в ветке main и хотите вывести разницу между тем коммитом, который был три коммита назад, и текущим, нужно выполнить git diff main~3 main.  
 
## 17. Объединяем и удаляем ветки

**git merge <название_ветки>**- выполнить слияние;  

Перед тем как начать процесс слияния, нужно перейти в ветку, куда должны добавиться изменения. Обычно это главная ветка.  
Перейдите в неё и вызовите команду git merge с именем присоединяемой ветки feature/diff в качестве параметра.  

**git branch -D <название_ветки>** - удалить ветку после слияния.  
**git branch -d br-name** - удалить ветку, но только если она является частью main  

После того как произошло слияние, ветку-донора можно удалить. Для этого в основной ветке введите команду git branch с флагом -D (от англ. delete — «удалить») и названием ветки.  
Если в момент удаления вы будете находиться в той ветке, которую хотите удалить, Git сообщит об ошибке: can not delete branch (англ. «не получается удалить ветку»).  
У команды git branch -D есть более безопасный вариант с флагом -d. Он удалит ветку только если она была полностью объединена с другой — то есть если две ветки стали (или изначально были) частью одной истории. Например, если вы нечаянно создали ветку с неправильным названием, её можно удалить через git branch -d %имя_ветки%.  
 Удаление локальной ветки через Git не удаляет ветку на GitHub!  

## 18.Создаём pull request  

Пул-реквест — это запрос на рассмотрение предлагаемых изменений и часть процесса ревью.  
Нельзя просто внести правки в своей ветке и сразу залить её в основную. Сначала ваши коллеги должны убедиться, что предложенные вами изменения логичны и эффективны.  
Для этого используют механизм pull request.  

Алгоритм такой:

    Вы трудитесь над задачей в своей ветке — например, пишете код новой функциональности.  
    Вы заканчиваете работу, а затем создаёте пул-реквест.  
    Ваши коллеги проверяют, что код выглядит аккуратно и лаконично, а программа работает корректно; также оставляют комментарии. Этот процесс называют code review (англ. «рассмотрение кода»), или просто ревью.  
    После финального согласования вы заливаете свою ветку в основную.  

Из чего состоит pull request и чем он может обернуться  
У каждого пул-реквеста есть:  

    Название — краткое описание предлагаемых изменений. Например: Адаптивный заголовок сайта, Замена альбома на галерею и так далее.  
    Описание — развёрнутое описание изменений. Это поле заполнять необязательно, но желательно.  
    Исходная ветка — та, в которой вы работали. Например, feature/merge-request.  
    Целевая ветка — основная ветка проекта, в которую вы хотите внести изменения.  

Где заполнять эти параметры, вы увидите далее — в ходе тренировки. Также у каждого пул-реквеста может быть два исхода:  

    merge (англ. «соединить») — предлагаемые изменения приняты; код вливается в целевую ветку; пул-реквест закрывается.  
    close (англ. «закрыть») — пул-реквест закрывается без слияния изменений.  

Запрос на изменения можно инициировать двумя способами: через ссылку, которую Git выводит после создания ветки, или через интерфейс GitHub.  
После создания пул-реквеста ваши коллеги сделают ревью — оценят предложенные вами правки и оставят свои комментарии.  
По результатам ревью ваши правки могут быть приняты в основную ветку проекта или возвращены на доработку.  

## 19. Забираем изменения из удалённого репозитория  

**git pull** - забрать изменения из удаленого репозитория.  

Обычно git pull — это первая команда, которую вводит разработчик, как только открывает код проекта, чтобы начать с ним работать.  
Дополнительно git pull и git merge выполняют перед тем, как создать пул-реквест.  
При командной работе, особенно в больших командах, основная ветка часто успевает «убежать» вперёд, пока вы подготавливаете свои изменения.  
Поэтому перед созданием пул-реквеста рекомендуется сначала подтянуть изменения из основной ветки, объединить их с вашей, решить все возможные конфликты и лишь затем сделать push.  
Перед созданием нового пул-реквеста считается хорошей практикой перейти в главную ветку, «подтянуть» в неё изменения, а затем добавить эти изменения в вашу ветку с помощью git merge main.  

**git remote rm origin** - удалить текущий привязанный origin (при форк проекта).  

**git reset --hard <хэш>** 
**git push --force** - удадить коммиты с ГитХаб